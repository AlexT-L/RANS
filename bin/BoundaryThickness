import numpy as np
from Grid import Grid

class BoundaryThickness():
    def boundary_thickness(params, dims):
        # from subroutine delt
        # # calculates the boundary layer thickness
        # uses dims, flo_var, mesh_var, solv_var, flo_param, solv_param
        # js        = 2*jl/3  -2
        js        = .75*(ny  -4)

        # one big loop 
        for i in range(1,il):
            qs[0]     = 0.
            ut[0]     = 0.
            j         = js
            xy        = .5*(x[i,j,1]  -x[i,j-1,1]+x[i-1,j,1]  -x[i-1,j-1,1])
            yy        = .5*(x[i,j,2]  -x[i,j-1,2]+x[i-1,j,2]  -x[i-1,j-1,2])
            qs[j]     = (yy*w[i,j,2]  -xy*w[i,j,3])/(w[i,j,1])
            si        = sign(1.,qs[js])

            for j in range(1,js):
                xy        = .5*(x[i,j,1]  -x[i,j-1,1]+x[i-1,j,1]  -x[i-1,j-1,1])
                yy        = .5*(x[i,j,2]  -x[i,j-1,2]+x[i-1,j,2]  -x[i-1,j-1,2])
                dsi       = 1./np.sqrt(xy**2  +yy**2)
                qs[j]     = si*(yy*w[i,j,2]  -xy*w[i,j,3])
                dn[j]     = 1./dsi
                ut[j]     = qs[j]*dsi

            dsti[i]   = 0.
            ynot[i]   = 0.
            ssmax[i]  = 0.
            cdu       = .98
            jmax      = idmax[js,ut,1]
            fx        = .6*ut[jmax]
            lend      = 2
            lbig      = 2
            locke     = False

            for  j in range(2,js):
                if ( ut[j-1] < 0 and ut[j] >= 0):
                    lbig = j

                if not locke:
                    if ( ut[j-1] >= cdu*ut[j] and ut[j] > fx):
                        locke     = True
                        lend      = j

            uinf      = 1./ut[lend]
            for j in range(lbig-1,lend):
                dsti [i]  = dsti[i] + (ut[lend]*dn[j] - qs[j])
                ra        = w[i,lend,1]/w[i,j,1]
                ssmax[i]  = ssmax[i] + ra*ut[j]*uinf*(dn[j]-qs[j]*uinf)

            dsti[i]   = dsti[i]*uinf
            dsti [i]  = np.max(dsti[i],1.e-6)
            ra        = w[i,lend,1]/w[i,2,1]
            ssmax[i]  = np.max(ssmax[i],ra*qs[2]*uinf)
            fc        = .95*ut[lend]

            jse       = lend
            for j in range(1,jse):
                lend      = j  -1
                if (ut[j] > fc):
                    break

            xbi       = .5*(x[i,1,1]+x[i-1,1,1])
            ybi       = .5*(x[i,1,2]+x[i-1,1,2])
            ycorr     = np.sqrt((xc[i,lend,1] - xbi)**2+(xc[i,lend,2]-ybi)**2)
            ynot[i]   = 1.5*(ycorr  +dn[lend]*(fc  -ut[lend])/(ut[lend+1]  -ut[lend]))

        return

