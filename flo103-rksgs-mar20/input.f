      subroutine input
c
c     ******************************************************************
c     *                                                                *
c     *   input the aerodynamic and geometric data                     *
c     *                                                                *
c     ******************************************************************
c
      use dims
c
c     ******************************************************************
c
      use in_var
c
c     ******************************************************************
c
      use flo_param
      use solv_param
      use mg_param
      use geo_param
c
c     ******************************************************************
c
      implicit none
c
c     ******************************************************************
c
      common/psp/ npgrid,npcp,npcnv
      common/ims/ imesh,iin
c
c     ******************************************************************
c
      common/tit/ title
c
c     ******************************************************************
c
      integer  :: npgrid,npcp,npcnv
      integer  :: imesh,iin
c
c     ******************************************************************
c
      character(80) :: title
c
c     ******************************************************************
c
c     local variables
c
c     ******************************************************************
c
      integer  :: iread,iwrit
      integer  :: i,j,k,m
      integer  :: nu,nl,maxdim
      integer  :: ksym,is1,is2
c
c     ******************************************************************
c
      real     :: fnx,fny,fmesh,rmesh,riin
      real     :: fsmoop,hcyc
      real     :: rad,al
      real     :: fvis
      real     :: fsym,fnu,fnl
      real     :: thick,sle,gmm,pmax
      real     :: fcut
      real     :: prec
c
c     ******************************************************************
c
      iread     = 5
      iwrit     = 6
      rad       = 45./atan(1.)
c
c     initialize the plot files
c
      open  (18,file='GRID.PLOT')
      endfile 18
      close (18,status='delete')
      open  (18,file='CP.PLOT')
      endfile 18
      close (18,status='delete')
      open  (18,file='CNV.PLOT')
      endfile 18
      close (18,status='delete')

      npgrid    = 0
      npcp      = 0
      npcnv     = 0
c
c     ******************************************************************
c     *                                                                *
c     *   read the title of the case to be calculated                  *
c     *                                                                *
c     ******************************************************************
c
c     (this will be included in the output)
c
      read  (iread,530) title
      write (iwrit,630) title
c
c     ******************************************************************
c     *                                                                *
c     *   read the dimensions of the first mesh                        *
c     *   and parameters controlling the meshes to be used             *
c     *                                                                *
c     ******************************************************************
c
c     fnx       = the number of cells in the i direction
c     fny       = the number of cells in the j direction
c     fmesh     = the number of meshes on which the solution
c                 is to be calculated,with nx,ny and nz doubled
c                 on each successive mesh
c     rmesh     = 0. if the mesh is to be generated by the program
c     rmesh     = 1. if the mesh is to be generated externally and read
c                 (the mesh which is read has the final dimensions)
c     riin      = the unit number from the mesh is to be read
c
      read  (iread,500)
      read  (iread,510) fnx,fny,fmesh,rmesh,riin
      nx        = fnx
      ny        = fny
      mmesh     = fmesh
      imesh     = rmesh
      iin       = riin
      if (nx.lt.1) stop
c
c     ******************************************************************
c     *                                                                *
c     *   for each mesh read parameters controlling the calculation    *
c     *                                                                *
c     ******************************************************************
c
c     fcyc      = the number of cycles
c     fprnt     = the interval at which the solution is printed
c     fout      = the interval at which convergence is monitored
c     ftim      = the interval at which the permissible time step
c                 is calculated (1 for multigrid calculations)
c     gprnt       controls the initial printout
c     gprnt     = 0 gives no initial printout
c     gprnt     = 1 gives a printout of the mesh
c     gprnt     = 2 gives printouts of the mesh and the initial flow
c     hprnt     = the interval used in printing the solution
c     hmesh     = the number of meshes used in the multigrid sequence
c
      read  (iread,500)
      do m=1,mmesh
         read  (iread,510) fcyc(m),fprnt(m),fout(m),ftim(m),
     .                     gprnt(m),hprnt(m),hmesh(m)
      end do
c
c     ******************************************************************
c     *                                                                *
c     *   read parameters controlling the algorithm                    *
c     *                                                                *
c     ******************************************************************
c
c     cflf      = the courant number for the time step on the fine mesh
c                 (cflf.lt.0. selects the use of a variable local step)
c     bc        = optional  far field boundary conditions
c     vis2      = the coefficient for the adaptive dissipation
c     vis4      = the coefficient for the background dissipation
c     adis      = exponent for directional scaling of the dissipation
c                 (adis = 1. for isotropic dissipation)
c     hmf       = the enthalpy damping factor for the fine mesh
c
c     recommended values:
c
c     bc        = 1.
c     vis2      = 1.
c     vis4      = 1.
c     adis      = 2./3.(for stretched grids)
c     hmf       = .2
c
      read  (iread,500)
      read  (iread,510) cflf,cflim,vis2,vis4,adis,qdis,bc,hmf
c
c     ******************************************************************
c     *                                                                *
c     *   read parameters controlling the time stepping scheme         *
c     *                                                                *
c     ******************************************************************
c
c     cstp(k)   = fraction of the time step at each stage
c     cdis(k)   = fraction of the dissipative terms to be replaced
c                 (no evaluation if cdis(k).eq.0.)
c
c     the following schemes are well proven:
c
c     three stage scheme with one evaluation of the dissipative terms:
c         cstp(1)   cstp(2)   cstp(3)
c          .6        .6        1.
c         cdis(1)   cdis(2)   cdis(3)
c          1.        0.        0.
c
c     four stage scheme with two evaluations of the dissipative terms:
c         cstp(1)   cstp(2)   cstp(3)   cstp(4)
c          .25       1./3.     .5        1.
c         cdis(1)   cdis(2)   cdis(3)   cdis(4)
c          1.        .5        0.        0.
c
c     five stage scheme with three evaluations of the dissipative terms:
c         cstp(1)   cstp(2)   cstp(3)   cstp(4)   cstp(5)
c          .25       1./6.     .375      .5        1.
c         cdis(1)   cdis(2)   cdis(3)   cdis(4)   cdis(5)
c          1.        0.        .56       0.        .44
c
      read  (iread,500)
      read  (iread,510) cstp(1),cstp(2),cstp(3),cstp(4),cstp(5),cstp(6)

      read  (iread,500)
      read  (iread,510) cdis(1),cdis(2),cdis(3),cdis(4),cdis(5),cdis(6)
      cdis(1)   = 1.
c
c     use the standard five stage scheme if cstp(1).le.0.
c
      if (cstp(1).le.0.) then
         cstp(1)   = .25
         cstp(2)   = 1./6.
         cstp(3)   = .375
         cstp(4)   = .5
         cstp(5)   = 1.
         cdis(1)   = 1.
         cdis(2)   = 0.
         cdis(3)   = .56
         cdis(4)   = 0.
         cdis(5)   = .44
      end if

      mstage    = 1
      do k=1,6
         if (cstp(k).ne.0.) mstage = k
      end do
c
c     ******************************************************************
c     *                                                                *
c     *   read parameters controlling the use of implicit smoothing    *
c     *   for residual averaging and for the multigrid corrections     *
c     *                                                                *
c     ******************************************************************
c
c     smoopi    = smoothing coefficient for the i direction
c     smoopj    = smoothing coefficient for the j direction
c     fsmoop      controls the use of residual averaging:
c     fsmoop    = 0. for no residual averaging
c     fsmoop    = 1. for residual averaging at all stages
c     fsmoop    = -1. for residual averaging at alternate stages
c
c     recommended values to double the permissible courant number:
c         smoopi    smoopj
c          .6        .6
c
      read  (iread,500)
      read  (iread,510) smoopi,smoopj,fsmoop,vt
      ksmoop    = fsmoop
      if (cflf .lt. 0) vt = 0.
c     if (vt.ne.0.) vt = 1.
      cflf      = abs(cflf)

      if (cflim.le.0.) cflim = float(mstage)  -1.5
c
c     ******************************************************************
c     *                                                                *
c     *   read parameters controlling the sgs preconditioner           *
c     *                                                                *
c     ******************************************************************
c
      read  (iread,500)
      read  (iread,510) prec,epsf,epsc,diag
c
c     prec .ne. 0 turns on the Gauss-Seidel preconditioner
c
      iprec     = prec
c
c     ******************************************************************
c     *                                                                *
c     *   read parameters controlling the multigrid scheme             *
c     *                                                                *
c     ******************************************************************
c
c     cflc      = the courant number for time steps on the coarse meshes
c     hmc       = the enthalpy damping factor for the coarse meshes
c     fbc         controls the far field boundary condition
c     fbc       = 0. to freeze the far field on the coarse meshes
c     fbc       = 1. to update the far field on the coarse meshes
c     fcoll     = a relaxation factor for the collected residuals
c     fadd        controls the smoothing of the interpolated corrections
c     vis0      = the dissipative coefficient for the coarse meshes
c     hcyc        controls the multigrid cycle
c     hcyc      = 1. for a v cycle
c     hcyc      = 2. for a w cycle
c
c     recommended values:
c
c     fbc       = 0. for subsonic and transonic inviscid flow
c     fbc       = 1. for supersonic inviscid, and for viscous flow
c     fcoll     = 1.
c     fadd      = 0. for subsonic and transonic flow
c     fadd      = 1. for supersonic inviscid, and for viscous flow
c     vis0      = 1.
c     hcyc      = 2.
c
      read  (iread,500)
      read  (iread,510) cflc,fcoll,fadd,vis0,hmc,fbc,hcyc
      if (cflc.eq.0) cflc = cflf

      lcyc      = hcyc
      if (lcyc.le.0) lcyc = 2
c
c     ******************************************************************
c     *                                                                *
c     *   input the aerodynamic data                                   *
c     *                                                                *
c     ******************************************************************
c
c     rm        = the mach number
c     al        = the angle of attack in degrees
c     fcl         controls the option to fix the lift coefficient
c     fcl       = 0. for fixed angle of attack
c     fcl       = 1. for fixed lift coefficient
c     clt       = the target lift coefficient
c     cd0       = the parasite drag coefficient
c
      read  (iread,500)
      read  (iread,510) rm,al,fcl,clt,cd0
      alpha     = al/rad
      ca        = cos(alpha)
      sa        = sin(alpha)
c
c     re        = the reynolds number
c     prn       = the prandtl number
c     prt       = the turbulent prandtl number
c     xtran     = the transition point
c     fvis        selects the mathematical model
c     fvis      = 0 for inviscid flow
c     fvis      = 1  for laminar flow
c     fvis      = 2  for turbulent flow
c
      read  (iread,500)
      read  (iread,510) re,prn,prt,t0,xtran,fvis

      kvis      = fvis
      if (kvis.gt.1) re = re*1.e06
      kturb     = 1

      if (prn.le.0.) prn = .725
      if (prt.le.0.) prt = .9
      if (t0.le.0.) t0 = 300.
c
c     set the constants and far field values
c
      gamma     = 1.4
      rho0      = 1.
      p0        = 1.
      c0        = sqrt(gamma*p0/rho0)
      ei0       = p0/((gamma  -1.)*rho0)
      u0        = rm*c0*ca
      v0        = rm*c0*sa
      h0        = gamma*ei0  +.5*(u0*u0  +v0*v0)
      rmu0      = 1.461e-06*t0*sqrt(t0)/(t0+110.3)
c
c     if imesh.ge.1 read the mesh
c
      if (imesh.gt.1) return
c
c     ******************************************************************
c     *                                                                *
c     *   input parameters controlling the mesh limits and stretching  *
c     *                                                                *
c     ******************************************************************
c
      read  (iread,500)
c     read  (iread,510) boundx,boundy,bunch,xte,ax,ay,sy
      read  (iread,510) boundx,boundy,bunch
      if (boundx.le.0.) boundx = .99
      if (boundx.ge.1.) boundx = .99
      if (boundy.le.0.) boundy = .96
      if (boundy.ge.1.) boundy = .96
      if (bunch.le.0.) bunch = 0.
      if (bunch.ge.1.) bunch = .5

      read  (iread,500)
      read  (iread,510) xte,ylim1,ylim2,ax,ay,sy
      if (xte.le.0.) xte = .625
      if (ylim1.le.0.) ylim1 = .625
      if (ylim2.le.0.) ylim2 = .5
      if (ax.le.0.) ax = 1.
      if (ay.le.0.) ay = 1.
      if (sy.le.0.) sy = .5

c     if (kvis.gt.0) then

      read  (iread,500)
      read  (iread,510) aplus,fcut
      if (aplus.le.0.) aplus = 1.
      ncut      = fcut
      if (ncut.le.0) ncut = 4

      if (kvis.eq.0) then
        aplus     = 1.
        ncut      = 4
      end if
c
c     ******************************************************************
c     *                                                                *
c     *   input the geometric definition                               *
c     *                                                                *
c     ******************************************************************
c
      read  (iread,500)
      read  (iread,510) fsym,fnu,fnl
      isym      = fsym
      nu        = fnu
      nl        = fnl

      read  (iread,500)
      read  (iread,510) trail,slopt,xsing,ysing

      nn        = nl  +nu  -1
      maxdim    = nx*2**(mmesh  -1)  +1
      maxdim    = max(maxdim,nn)
      allocate (xn(maxdim),yn(maxdim))

      read  (iread,500)
      do i=nl,nn
         read  (iread,510) xn(i),yn(i)
      end do

      m         = nl  +1
      if (isym.gt.0) go to 25

      read  (iread,500)
      do i=1,nl
         m         = m  -1
         read (iread,510) xn(m),yn(m)
      end do

      go to 31

   25 do i=nl,nn
         m         = m  -1
         xn(m)     = xn(i)
         yn(m)     = -yn(i)
      end do

   31 chord     = xn(1)  -xn(nl)
      xm        = xn(nl)  +.25*chord
      ym        = yn(nl)

      write (iwrit,32)
   32 format(1x,'input coordinates'/
     .       3x,'      x     ','      y     ')

      thick     = 1.
      do i=1,nn
         yn(i)     = thick*yn(i)
         write (iwrit,610) xn(i),yn(i)
      end do

      write (iwrit,36)
   36 format(3x,'    xsing   ','    ysing   ','  te slope  ',
     .          '  te angle  ')
      write (iwrit,610) xsing,ysing,slopt,trail
      trail     = trail/rad

      return
c
c     ******************************************************************
c
  500 format(1x)
  510 format(8f10.6)
  530 format(a80)
  610 format(1x,6f12.4)
  630 format(a80)

      end
